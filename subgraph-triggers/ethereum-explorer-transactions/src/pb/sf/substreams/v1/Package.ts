// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0

import { Writer, Reader } from "as-proto/assembly";
import { FileDescriptorProto } from "../../../google/protobuf/FileDescriptorProto";
import { Modules } from "./Modules";
import { ModuleMetadata } from "./ModuleMetadata";
import { PackageMetadata } from "./PackageMetadata";
import { Any } from "../../../google/protobuf/Any";
import { NetworkParams } from "./NetworkParams";

export class Package {
  static encode(message: Package, writer: Writer): void {
    const protoFiles = message.protoFiles;
    for (let i: i32 = 0; i < protoFiles.length; ++i) {
      writer.uint32(10);
      writer.fork();
      FileDescriptorProto.encode(protoFiles[i], writer);
      writer.ldelim();
    }

    writer.uint32(40);
    writer.uint64(message.version);

    const modules = message.modules;
    if (modules !== null) {
      writer.uint32(50);
      writer.fork();
      Modules.encode(modules, writer);
      writer.ldelim();
    }

    const moduleMeta = message.moduleMeta;
    for (let i: i32 = 0; i < moduleMeta.length; ++i) {
      writer.uint32(58);
      writer.fork();
      ModuleMetadata.encode(moduleMeta[i], writer);
      writer.ldelim();
    }

    const packageMeta = message.packageMeta;
    for (let i: i32 = 0; i < packageMeta.length; ++i) {
      writer.uint32(66);
      writer.fork();
      PackageMetadata.encode(packageMeta[i], writer);
      writer.ldelim();
    }

    writer.uint32(74);
    writer.string(message.network);

    const sinkConfig = message.sinkConfig;
    if (sinkConfig !== null) {
      writer.uint32(82);
      writer.fork();
      Any.encode(sinkConfig, writer);
      writer.ldelim();
    }

    writer.uint32(90);
    writer.string(message.sinkModule);

    writer.uint32(98);
    writer.bytes(message.image);

    const networks = message.networks;
    if (networks !== null) {
      const networksKeys = networks.keys();
      for (let i: i32 = 0; i < networksKeys.length; ++i) {
        const networksKey = networksKeys[i];
        writer.uint32(106);
        writer.fork();
        writer.uint32(10);
        writer.string(networksKey);
        writer.uint32(18);
        writer.fork();
        NetworkParams.encode(networks.get(networksKey), writer);
        writer.ldelim();
        writer.ldelim();
      }
    }

    const blockFilters = message.blockFilters;
    if (blockFilters !== null) {
      const blockFiltersKeys = blockFilters.keys();
      for (let i: i32 = 0; i < blockFiltersKeys.length; ++i) {
        const blockFiltersKey = blockFiltersKeys[i];
        writer.uint32(114);
        writer.fork();
        writer.uint32(10);
        writer.string(blockFiltersKey);
        writer.uint32(18);
        writer.string(blockFilters.get(blockFiltersKey));
        writer.ldelim();
      }
    }
  }

  static decode(reader: Reader, length: i32): Package {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Package();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.protoFiles.push(
            FileDescriptorProto.decode(reader, reader.uint32())
          );
          break;

        case 5:
          message.version = reader.uint64();
          break;

        case 6:
          message.modules = Modules.decode(reader, reader.uint32());
          break;

        case 7:
          message.moduleMeta.push(
            ModuleMetadata.decode(reader, reader.uint32())
          );
          break;

        case 8:
          message.packageMeta.push(
            PackageMetadata.decode(reader, reader.uint32())
          );
          break;

        case 9:
          message.network = reader.string();
          break;

        case 10:
          message.sinkConfig = Any.decode(reader, reader.uint32());
          break;

        case 11:
          message.sinkModule = reader.string();
          break;

        case 12:
          message.image = reader.bytes();
          break;

        case 13:
          let networksKey: string = "";
          let networksValue: NetworkParams | null = null;
          let networksHasKey: bool = false;
          let networksHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                networksKey = reader.string();
                networksHasKey = true;
                break;

              case 2:
                networksValue = NetworkParams.decode(reader, reader.uint32());
                networksHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.networks === null) {
              message.networks = new Map<string, NetworkParams>();
            }
            const networks = message.networks;
            if (
              networks !== null &&
              networksHasKey &&
              networksHasValue &&
              networksValue !== null
            ) {
              networks.set(networksKey, networksValue);
            }
          }
          break;

        case 14:
          let blockFiltersKey: string = "";
          let blockFiltersValue: string = "";
          let blockFiltersHasKey: bool = false;
          let blockFiltersHasValue: bool = false;
          for (
            const end: usize = reader.ptr + reader.uint32();
            reader.ptr < end;

          ) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                blockFiltersKey = reader.string();
                blockFiltersHasKey = true;
                break;

              case 2:
                blockFiltersValue = reader.string();
                blockFiltersHasValue = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.blockFilters === null) {
              message.blockFilters = new Map<string, string>();
            }
            const blockFilters = message.blockFilters;
            if (
              blockFilters !== null &&
              blockFiltersHasKey &&
              blockFiltersHasValue
            ) {
              blockFilters.set(blockFiltersKey, blockFiltersValue);
            }
          }
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  protoFiles: Array<FileDescriptorProto>;
  version: u64;
  modules: Modules | null;
  moduleMeta: Array<ModuleMetadata>;
  packageMeta: Array<PackageMetadata>;
  network: string;
  sinkConfig: Any | null;
  sinkModule: string;
  image: Uint8Array;
  networks: Map<string, NetworkParams>;
  blockFilters: Map<string, string>;

  constructor(
    protoFiles: Array<FileDescriptorProto> = [],
    version: u64 = 0,
    modules: Modules | null = null,
    moduleMeta: Array<ModuleMetadata> = [],
    packageMeta: Array<PackageMetadata> = [],
    network: string = "",
    sinkConfig: Any | null = null,
    sinkModule: string = "",
    image: Uint8Array = new Uint8Array(0),
    networks: Map<string, NetworkParams> = new Map(),
    blockFilters: Map<string, string> = new Map()
  ) {
    this.protoFiles = protoFiles;
    this.version = version;
    this.modules = modules;
    this.moduleMeta = moduleMeta;
    this.packageMeta = packageMeta;
    this.network = network;
    this.sinkConfig = sinkConfig;
    this.sinkModule = sinkModule;
    this.image = image;
    this.networks = networks;
    this.blockFilters = blockFilters;
  }
}
