// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v1.3.0

import { Writer, Reader } from "as-proto/assembly";
import { KindMap } from "./Module/KindMap";
import { KindStore } from "./Module/KindStore";
import { KindBlockIndex } from "./Module/KindBlockIndex";
import { Input } from "./Module/Input";
import { Output } from "./Module/Output";
import { BlockFilter } from "./Module/BlockFilter";

export class Module {
  static encode(message: Module, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.name);

    const kindMap = message.kindMap;
    if (kindMap !== null) {
      writer.uint32(18);
      writer.fork();
      KindMap.encode(kindMap, writer);
      writer.ldelim();
    }

    const kindStore = message.kindStore;
    if (kindStore !== null) {
      writer.uint32(26);
      writer.fork();
      KindStore.encode(kindStore, writer);
      writer.ldelim();
    }

    const kindBlockIndex = message.kindBlockIndex;
    if (kindBlockIndex !== null) {
      writer.uint32(82);
      writer.fork();
      KindBlockIndex.encode(kindBlockIndex, writer);
      writer.ldelim();
    }

    writer.uint32(32);
    writer.uint32(message.binaryIndex);

    writer.uint32(42);
    writer.string(message.binaryEntrypoint);

    const inputs = message.inputs;
    for (let i: i32 = 0; i < inputs.length; ++i) {
      writer.uint32(50);
      writer.fork();
      Input.encode(inputs[i], writer);
      writer.ldelim();
    }

    const output = message.output;
    if (output !== null) {
      writer.uint32(58);
      writer.fork();
      Output.encode(output, writer);
      writer.ldelim();
    }

    writer.uint32(64);
    writer.uint64(message.initialBlock);

    const blockFilter = message.blockFilter;
    if (blockFilter !== null) {
      writer.uint32(74);
      writer.fork();
      BlockFilter.encode(blockFilter, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Module {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Module();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;

        case 2:
          message.kindMap = KindMap.decode(reader, reader.uint32());
          break;

        case 3:
          message.kindStore = KindStore.decode(reader, reader.uint32());
          break;

        case 10:
          message.kindBlockIndex = KindBlockIndex.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.binaryIndex = reader.uint32();
          break;

        case 5:
          message.binaryEntrypoint = reader.string();
          break;

        case 6:
          message.inputs.push(Input.decode(reader, reader.uint32()));
          break;

        case 7:
          message.output = Output.decode(reader, reader.uint32());
          break;

        case 8:
          message.initialBlock = reader.uint64();
          break;

        case 9:
          message.blockFilter = BlockFilter.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  name: string;
  kindMap: KindMap | null;
  kindStore: KindStore | null;
  kindBlockIndex: KindBlockIndex | null;
  binaryIndex: u32;
  binaryEntrypoint: string;
  inputs: Array<Input>;
  output: Output | null;
  initialBlock: u64;
  blockFilter: BlockFilter | null;

  constructor(
    name: string = "",
    kindMap: KindMap | null = null,
    kindStore: KindStore | null = null,
    kindBlockIndex: KindBlockIndex | null = null,
    binaryIndex: u32 = 0,
    binaryEntrypoint: string = "",
    inputs: Array<Input> = [],
    output: Output | null = null,
    initialBlock: u64 = 0,
    blockFilter: BlockFilter | null = null
  ) {
    this.name = name;
    this.kindMap = kindMap;
    this.kindStore = kindStore;
    this.kindBlockIndex = kindBlockIndex;
    this.binaryIndex = binaryIndex;
    this.binaryEntrypoint = binaryEntrypoint;
    this.inputs = inputs;
    this.output = output;
    this.initialBlock = initialBlock;
    this.blockFilter = blockFilter;
  }
}
